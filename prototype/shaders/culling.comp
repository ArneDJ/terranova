#version 460 core

layout(local_size_x = 16, local_size_y = 1, local_size_z = 1) in;

struct IndexedIndirectCommand {
	uint indexCount;
	uint instanceCount;
	uint firstIndex;
	uint vertexOffset;
	uint firstInstance;
};

// Binding 1: Multi draw output
layout (std430, binding = 0) writeonly buffer IndirectDraws
{
	IndexedIndirectCommand indirect_draws[];
};

layout (std430, binding = 1) readonly buffer transforms
{
	float transform_SSBO[];
};

// TODO put in UBO
uniform vec4 FRUSTUM_FRONT;
uniform vec4 FRUSTUM_BACK;
uniform vec4 FRUSTUM_LEFT;
uniform vec4 FRUSTUM_RIGHT;
uniform vec4 FRUSTUM_TOP;
uniform vec4 FRUSTUM_BOTTOM;

bool sphere_intersection(vec4 pos, float radius)
{
	vec4 frustum_planes[6] = {
		FRUSTUM_FRONT,
		FRUSTUM_BACK,
		FRUSTUM_LEFT,
		FRUSTUM_RIGHT,
		FRUSTUM_TOP,
		FRUSTUM_BOTTOM
	};

	for (int i = 0; i < 6; i++) {
		if (dot(pos, frustum_planes[i]) + radius < 0.0) {
			return false;
		}
	}

	return true;
}

void main()
{
	//uint idx = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * gl_NumWorkGroups.x * gl_WorkGroupSize.x;
	uint idx = gl_GlobalInvocationID.x;

	vec4 position = vec4(1.0);
	position.x = transform_SSBO[3 * gl_GlobalInvocationID.x];
	position.y = transform_SSBO[3 * gl_GlobalInvocationID.x+1];
	position.z = transform_SSBO[3 * gl_GlobalInvocationID.x+2];

	if (sphere_intersection(position, 1.0)) {
		indirect_draws[idx].instanceCount = 1;
	} else {
		indirect_draws[idx].instanceCount = 0;
	}
}
